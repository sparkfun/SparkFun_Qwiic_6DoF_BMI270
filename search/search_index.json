{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>The SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) is a Qwiic enabled board based on the ultra-low power BMI270 from Bosch. This chip is a highly integrated, low power IMU designed for wearable, smart clothing and AR/VR applications. Not only does the BMI270 comprise a fast and sensitive accelerometer and gyro pair, but it also contains a number of intelligent, on-chip motion-triggered interrupt features.  </p> <p> Purchase from SparkFun  </p> <p></p> <p>The SparkFun Micro 6DoF IMU Breakout - BMI270 (Qwiic) is the 1x1's mini-me, containing most of it's elder sibling's functionality in a tiny little package. </p> <p> Purchase from SparkFun  </p>"},{"location":"#required-materials","title":"Required MaterialsSparkFun 6DoF IMU Breakout - BMI270 (Qwiic)SparkFun Micro 6DoF IMU Breakout - BMI270 (Qwiic)Flexible Qwiic Cable - 100mmUSB micro-B Cable - 6 FootSparkFun ESP32 Thing Plus","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary.</p>              SEN-22397                       SEN-22398                       PRT-17259                       CAB-10215                       DEV-15663"},{"location":"#suggested-reading","title":"Suggested Reading","text":"<p>If you aren\u2019t familiar with the following concepts, we recommend checking out these tutorials before continuing.</p> <ul> <li> <p> I2C </p> </li> <li> <p> Serial Terminal Basics </p> </li> </ul> <p> <p></p> <p>The SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) Sensor takes advantage of the Qwiic connect system. We recommend familiarizing yourself with the Logic Levels and I<sup>2</sup>C tutorials.  Click on the banner above to learn more about Qwiic products.</p> <p> </p>"},{"location":"contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun 6DoF - BMI270 (Qwiic) repository.</li> </ul>"},{"location":"contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li> <p>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Qwiic 6DoF BMI270 repository.</p> </li> <li> <p>With a GitHub account, fork this repository.</p> </li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ul>"},{"location":"contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"examples/","title":"Examples","text":"<p>The Arduino Library for the SparkFun 6DoF BMI270 (Qwiic) comes with a slew of examples to get you going. Here we'll just look at a few. </p> <p>Attention</p> <p><p>The BMI270 chip requires an 8kb file to be flashed to memory on the controller. Make sure that whatever controlling board you use, it has enough space. </p></p>"},{"location":"examples/#example-1-basic-readings","title":"Example 1: Basic Readings","text":"<p>This first example just does some basic measurements. To find Example 1, go to File &gt; Examples &gt; SparkFun BMI270 Arduino Library &gt; Example01_BasicReadingsI2C:</p> <p></p> <p>Finding Example 1</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 1 Arduino Code <pre><code>#include &lt;Wire.h&gt;\n#include \"SparkFun_BMI270_Arduino_Library.h\"\n\n// Create a new sensor object\nBMI270 imu;\n\n// I2C address selection\nuint8_t i2cAddress = BMI2_I2C_PRIM_ADDR; // 0x68\n//uint8_t i2cAddress = BMI2_I2C_SEC_ADDR; // 0x69\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"BMI270 Example 1 - Basic Readings I2C\");\n\n    // Initialize the I2C library\n    Wire.begin();\n\n    // Check if sensor is connected and initialize\n    // Address is optional (defaults to 0x68)\n    while(imu.beginI2C(i2cAddress) != BMI2_OK)\n    {\n        // Not connected, inform user\n        Serial.println(\"Error: BMI270 not connected, check wiring and I2C address!\");\n\n        // Wait a bit to see if connection is established\n        delay(1000);\n    }\n\n    Serial.println(\"BMI270 connected!\");\n}\n\nvoid loop()\n{\n    // Get measurements from the sensor. This must be called before accessing\n    // the sensor data, otherwise it will never update\n    imu.getSensorData();\n\n    // Print acceleration data\n    Serial.print(\"Acceleration in g's\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(imu.data.accelX, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(imu.data.accelY, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.print(imu.data.accelZ, 3);\n\n    Serial.print(\"\\t\");\n\n    // Print rotation data\n    Serial.print(\"Rotation in deg/sec\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(imu.data.gyroX, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(imu.data.gyroY, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.println(imu.data.gyroZ, 3);\n\n    // Print 50x per second\n    delay(20);\n}\n</code></pre> <p>Make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor. You should see something similar to the following. </p> <p></p> <p>Example 1 Output</p>"},{"location":"examples/#example-6-calibration-to-nvm","title":"Example 6: Calibration to NVM","text":"<p>This example does some basic calibration of the BMI270 and then allows you to write those calibrations to non volatile memory. To find Example 6, go to File &gt; Examples &gt; SparkFun BMI270 Arduino Library &gt; Example06_CalibrationNVM. </p> <p></p> <p>Finding Example 6</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 6 Arduino Code <pre><code>#include &lt;Wire.h&gt;\n#include \"SparkFun_BMI270_Arduino_Library.h\"\n\n// Create a new sensor object\nBMI270 imu;\n\n// I2C address selection\nuint8_t i2cAddress = BMI2_I2C_PRIM_ADDR; // 0x68\n//uint8_t i2cAddress = BMI2_I2C_SEC_ADDR; // 0x69\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"BMI270 Example 6 - Calibration NVM\");\n\n    // Initialize the I2C library\n    Wire.begin();\n\n    // Check if sensor is connected and initialize\n    // Address is optional (defaults to 0x68)\n    while(imu.beginI2C(i2cAddress) != BMI2_OK)\n    {\n        // Not connected, inform user\n        Serial.println(\"Error: BMI270 not connected, check wiring and I2C address!\");\n\n        // Wait a bit to see if connection is established\n        delay(1000);\n    }\n\n    Serial.println(\"BMI270 connected!\");\n\n    Serial.println(\"Place the sensor on a flat surface and leave it stationary.\");\n    Serial.println(\"Enter any key to begin calibration.\");\n\n    // Throw away any previous inputs\n    while(Serial.available() != 0) {Serial.read();}\n    // Wait for user input\n    while(Serial.available() == 0) {}\n\n    Serial.println();\n    Serial.println(\"Average sensor values before calibration:\");\n    printAverageSensorValues();\n    Serial.println();\n\n    // Perform component retrim for the gyroscope. According to the datasheet,\n    // the gyroscope has a typical error of 2%, but running the CRT can reduce\n    // that error to 0.4%\n    Serial.println(\"Performing component retrimming...\");\n    imu.performComponentRetrim();\n\n    // Perform offset calibration for both the accelerometer and IMU. This will\n    // automatically determine the offset of each axis of each sensor, and\n    // that offset will be subtracted from future measurements. Note that the\n    // offset resolution is limited for each sensor:\n    // \n    // Accelerometer offset resolution: 0.0039 g\n    // Gyroscope offset resolution: 0.061 deg/sec\n    Serial.println(\"Performing acclerometer offset calibration...\");\n    imu.performAccelOffsetCalibration(BMI2_GRAVITY_POS_Z);\n    Serial.println(\"Performing gyroscope offset calibration...\");\n    imu.performGyroOffsetCalibration();\n\n    Serial.println();\n    Serial.println(\"Calibration complete!\");\n    Serial.println();\n    Serial.println(\"Average sensor values after calibration:\");\n    printAverageSensorValues();\n    Serial.println();\n\n    Serial.println(\"These calibration values can be stored in the sensor's non-volatile memory (NVM).\");\n    Serial.println(\"Would you like to save these values to the NVM? If so, enter 'Y'\");\n\n    // Throw away any previous inputs\n    while(Serial.available() != 0) {Serial.read();}\n    // Wait for user input\n    while(Serial.available() == 0) {}\n\n    // Check to see if user wants to save values to NVM\n    if(Serial.read() == 'Y')\n    {\n        Serial.println();\n        Serial.println(\"!!! WARNING !!! WARNING !!! WARNING !!! WARNING !!! WARNING !!!\");\n        Serial.println();\n        Serial.println(\"The BMI270's NVM only supports 14 write cycles TOTAL!\");\n        Serial.println(\"Are you sure you want to save to the NVM? If so, enter 'Y' again\");\n\n        // Throw away any previous inputs\n        while(Serial.available() != 0) {Serial.read();}\n        // Wait for user input\n        while(Serial.available() == 0) {}\n\n        // Check to see if user *really* wants to save values to NVM\n        if(Serial.read() == 'Y')\n        {\n            // Save NVM contents\n            int8_t err = imu.saveNVM();\n\n            // Check to see if the NVM saved successfully\n            if(err == BMI2_OK)\n            {\n                Serial.println();\n                Serial.println(\"Calibration values have been saved to the NVM!\");\n            }\n            else\n            {\n                Serial.print(\"Error saving to NVM, error code: \");\n                Serial.println(err);\n            }\n        }\n    }\n\n    Serial.println();\n    Serial.println(\"Example done!\");\n}\n\n// This helper function samples the sensor several times and prints the average\nvoid printAverageSensorValues()\n{\n    // Variables to store the sum of each sensor axis\n    float accXSum = 0;\n    float accYSum = 0;\n    float accZSum = 0;\n\n    float gyrXSum = 0;\n    float gyrYSum = 0;\n    float gyrZSum = 0;\n\n    // Collect 50 measurements at 50Hz\n    int numSamples = 50;\n    for(int i = 0; i &lt; numSamples; i++)\n    {\n        // Get measurements from the sensor\n        imu.getSensorData();\n\n        // Add this measurement to the running total\n        accXSum += imu.data.accelX;\n        accYSum += imu.data.accelY;\n        accZSum += imu.data.accelZ;\n\n        gyrXSum += imu.data.gyroX;\n        gyrYSum += imu.data.gyroY;\n        gyrZSum += imu.data.gyroZ;\n\n        // Wait for next measurement\n        delay(20);\n    }\n\n    // Print acceleration data\n    Serial.print(\"Acceleration in g's\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(accXSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(accYSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.print(accZSum / numSamples, 3);\n\n    Serial.print(\"\\t\");\n\n    // Print rotation data\n    Serial.print(\"Rotation in deg/sec\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(gyrXSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(gyrYSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.println(gyrZSum / numSamples, 3);\n}\n\nvoid loop()\n{\n    // Nothing to do here\n}\n</code></pre> <p>Again, make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor. You should see something similar to the following.</p> <p></p> <p>Example 6 Output</p> <p>Warning</p> <p>This chip only allows a total of 14 writes. Be mindful of this limit when recalibrating. </p>"},{"location":"examples/#example-12-step-counter","title":"Example 12: Step Counter","text":"<p>One of the highlights of the BMI270 chip is that it filters out general noise to give you accurate step counts and the like. This example shows the measurements of the BMI270 for walking, running, and when the breakout board is set back down. To find Example 12, go to File &gt; Examples &gt; SparkFun BMI270 Arduino Library &gt; Example12_StepCounter:</p> <p></p> <p>Finding Example 12</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 12 Arduino Code <pre><code>#include &lt;Wire.h&gt;\n#include \"SparkFun_BMI270_Arduino_Library.h\"\n\n// Create a new sensor object\nBMI270 imu;\n\n// I2C address selection\nuint8_t i2cAddress = BMI2_I2C_PRIM_ADDR; // 0x68\n//uint8_t i2cAddress = BMI2_I2C_SEC_ADDR; // 0x69\n\n// Pin used for interrupt detection\nint interruptPin = 5;\n\n// Flag to know when interrupts occur\nvolatile bool interruptOccurred = false;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"BMI270 Example 12 - Step Counter\");\n\n    // Initialize the I2C library\n    Wire.begin();\n\n    // Check if sensor is connected and initialize\n    // Address is optional (defaults to 0x68)\n    while(imu.beginI2C(i2cAddress) != BMI2_OK)\n    {\n        // Not connected, inform user\n        Serial.println(\"Error: BMI270 not connected, check wiring and I2C address!\");\n\n        // Wait a bit to see if connection is established\n        delay(1000);\n    }\n\n    Serial.println(\"BMI270 connected!\");\n\n    // Here we enable the step detector, counter, and activity recognition\n    // features of the BMI270; any combination of these is supported.\n    // \n    // DETECTOR - Triggers an interrupt whenever a step is detected\n    // COUNTER  - Increments a counter whenever a step is detected (detector\n    //            does not need to be enabled). Triggers an interrupt based on\n    //            the step counter watermark (see below)\n    // ACTIVITY - The sensor monitors the motion to determine simple user\n    //            activities, including standing still, walking, and running. An\n    //            interrupt is triggered whenever the activity changes\n    imu.enableFeature(BMI2_STEP_DETECTOR);\n    imu.enableFeature(BMI2_STEP_COUNTER);\n    imu.enableFeature(BMI2_STEP_ACTIVITY);\n\n    // When the step counter feature is enabled, it can trigger an interrupt\n    // every number of steps defined by the watermark. This has a factor of 20x,\n    // so a value of 1 means 20 step intervals. The step counter interrupt is\n    // disabled when the watermark is 0 (default)\n    // \n    // Note - The step counter and detector interrupts share the same bit in the\n    // interrupt status flags registers, so the step detector should be disabled\n    // to actually see the step counter interrupts\n    imu.setStepCountWatermark(1);\n\n    // The BMI270 has 2 interrupt pins. All interrupt conditions can be mapped\n    // to either pin, so we'll just choose the first one for this example\n    // \n    // Note - The step counter and detector interrupts share the same bit in the\n    // interrupt mapping registers, so enabling one enables both\n    imu.mapInterruptToPin(BMI2_STEP_COUNTER_INT, BMI2_INT1);\n    imu.mapInterruptToPin(BMI2_STEP_ACTIVITY_INT, BMI2_INT1);\n\n    // Here we configure the interrupt pins using a bmi2_int_pin_config, which \n    // allows for both pins to be configured simultaneously if needed. Here's a\n    // brief description of each value:\n    // \n    // .pin_type  - Which pin(s) is being configured (INT1, INT2, or BOTH)\n    // .int_latch - Latched or pulsed signal (applies to both pins)\n    // .pin_cfg   - Array of settings for each pin (index 0/1 for INT1/2):\n    //     .lvl       - Active high or low\n    //     .od        - Push/pull or open drain output\n    //     .output_en - Whether to enable outputs from this pin\n    //     .input_en  - Whether to enable inputs to this pin (see datasheet)\n    // \n    // In this case, we set INT1 to pulsed, active high, push/pull\n    bmi2_int_pin_config intPinConfig;\n    intPinConfig.pin_type = BMI2_INT1;\n    intPinConfig.int_latch = BMI2_INT_NON_LATCH;\n    intPinConfig.pin_cfg[0].lvl = BMI2_INT_ACTIVE_HIGH;\n    intPinConfig.pin_cfg[0].od = BMI2_INT_PUSH_PULL;\n    intPinConfig.pin_cfg[0].output_en = BMI2_INT_OUTPUT_ENABLE;\n    intPinConfig.pin_cfg[0].input_en = BMI2_INT_INPUT_DISABLE;\n    imu.setInterruptPinConfig(intPinConfig);\n\n    // Setup interrupt handler\n    attachInterrupt(digitalPinToInterrupt(interruptPin), myInterruptHandler, RISING);\n}\n\nvoid loop()\n{\n    // Wait for interrupt to occur\n    if(interruptOccurred)\n    {\n        // Reset flag for next interrupt\n        interruptOccurred = false;\n\n        Serial.print(\"Interrupt occurred!\");\n        Serial.print(\"\\t\");\n\n        // Get the interrupt status to know which condition triggered\n        uint16_t interruptStatus = 0;\n        imu.getInterruptStatus(&amp;interruptStatus);\n\n        // Check if this is the correct interrupt condition\n        if(interruptStatus &amp; BMI270_STEP_CNT_STATUS_MASK)\n        {\n            Serial.print(\"Step detected! Total step count: \");\n\n            // Get the step count\n            uint32_t count = 0;\n            imu.getStepCount(&amp;count);\n\n            // Print step count\n            Serial.print(count);\n            Serial.print(\"\\t\");\n        }\n        if(interruptStatus &amp; BMI270_STEP_ACT_STATUS_MASK)\n        {\n            Serial.print(\"Step activity changed! New activity: \");\n\n            // Get the step activity\n            uint8_t activity = 0;\n            imu.getStepActivity(&amp;activity);\n\n            // Print step activity\n            switch(activity)\n            {\n                case BMI2_STEP_ACTIVITY_STILL:\n                {\n                    Serial.print(\"Still, resetting step counter\");\n                    imu.resetStepCount();\n                    break;\n                }\n                case BMI2_STEP_ACTIVITY_WALKING:\n                {\n                    Serial.print(\"Walking\");\n                    break;\n                }\n                case BMI2_STEP_ACTIVITY_RUNNING:\n                {\n                    Serial.print(\"Running\");\n                    break;\n                }\n                default:\n                {\n                    Serial.print(\"Unknown!\");\n                    break;\n                }\n            }\n        }\n        if(!(interruptStatus &amp; (BMI270_STEP_CNT_STATUS_MASK | BMI270_STEP_ACT_STATUS_MASK)))\n        {\n            Serial.print(\"Unkown interrupt condition!\");\n        }\n\n        Serial.println();\n    }\n}\n\nvoid myInterruptHandler()\n{\n    interruptOccurred = true;\n}\n</code></pre> <p>The wiring for this example is fairly simple. Use the Qwiic connector as normal, and then you'll need to connect your INT1 pin to pin 5/SCK on the ESP32 Thing Plus. Here's what it looks like:</p> <p></p> <p>Example 12</p> <p>Once you get the correct port and board selected and the code is uploaded, you should see something like the following: </p> <p></p> <p>Example 12 Output</p>"},{"location":"file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Attention</p> <p>This is not where customers should seek assistance on a product. If you require technical assistance or have questions about a product that is not working as expected, please head over to the SparkFun Technical Assistance page for some initial troubleshooting.  SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, you'll need a Forum Account to search product forums and post questions.</p>"},{"location":"file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) repository.</li> </ul>"},{"location":"file_issue/#spot-something-wrong","title":"Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repo</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) repository. </li> </ul>"},{"location":"file_issue/#does-something-not-make-sense","title":"Does something not make sense?","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board?","text":"<ul> <li>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements. (For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.)</li> <li>If part of the board's functionality is missing, please open an issue and file a feature request.</li> </ul>"},{"location":"file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, Fork this repo</li> <li>Add your design improvement(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s), if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"},{"location":"hard_copy/","title":"Hard copy","text":"<p>Need to download or print our hookup guide?</p> <ul> <li>Print  (Single-Page View)<ul> <li>To save as a <code>*.pdf</code> file, select the Printer or Destination labeled Save as PDF. (Instructions will vary based on the browser)</li> </ul> </li> </ul>"},{"location":"hardware_assembly/","title":"Hardware Assembly","text":"<p>The delightful thing about our Qwiic boards is that they are quite literally plug and play. </p> <p></p> <p>SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) Plugged into the ESP32 Thing Plus</p> <p></p> <p>SparkFun Micro 6DoF IMU Breakout - BMI270 (Qwiic) Plugged into the ESP32 Thing Plus</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":""},{"location":"hardware_overview/#accelerometer-bmi270","title":"Accelerometer - BMI270","text":"<p>The ultra-low power BMI270 is an IMU optimized for wearables providing precise acceleration, angular rate measurement and intelligent on-chip motion-triggered interrupt features.</p> <p>The 6-axis sensor combines a 16-bit tri-axial gyroscope and a 16-bit tri-axial accelerometer featuring Bosch\u2019s automotive-proven gyroscope technology. BMI270 includes several functionalities such as an integrated plug-and-play step counter/detector and gesture detection for wrist-worn devices. Moreover, the IMU is suitable for hearables, smart clothes, smart shoes, smart glasses and ankle bands.</p> <p></p> <p>6DoF BMI270 IC</p> <p></p> <p>Micro 6DoF BMI270 IC</p>"},{"location":"hardware_overview/#qwiic-connector","title":"Qwiic Connector","text":"<p>The Qwiic connector(s) on the SparkFun 6DoF - BMI270 (Qwiic) and SparkFun 6DoF Micro - BMI270 (Qwiic) provide power and I<sup>2</sup>C connectivity simultaneously.</p> <p></p> <p>6DoF BMI270 Qwiic Connector</p> <p></p> <p>Micro 6DoF BMI270 Qwiic Connector</p>"},{"location":"hardware_overview/#power","title":"Power","text":"<p>Ideally, power to these boards will be provided by the Qwiic cables. However, should you wish to provide power separately, the 1\" x 1\" board has its pins broken out to PTH and you can wire up power via these. </p> <p>Warning</p> <p><p>Make sure to pay attention to logic levels - supply voltage range should be between 1.71V - 3.6V. </p></p> <p></p> <p>BMI270 Power Pins</p>"},{"location":"hardware_overview/#gpio","title":"GPIO","text":"<p>This is a quick overview of the pin functionality. For more information, refer to the datasheet.</p>"},{"location":"hardware_overview/#i2c","title":"I<sup>2</sup>C","text":"<p>If you do not want to use the Qwiic connectors, I<sup>2</sup>C functionality has been broken out to PTH pins on the 1x1\" board. </p> <p></p> <p>BMI270 I<sup>2</sup>C Pins</p>"},{"location":"hardware_overview/#spi","title":"SPI","text":"<p>Primary SPI functionality has been broken out to the highlighted pins below. </p> <p></p> <p>BMI270 SPI Pins</p> <p>SCL goes to SCK, SDA goes to PICO, ADR goes to POCI, and CS goes to CS</p>"},{"location":"hardware_overview/#auxiliary-interface","title":"Auxiliary Interface","text":"<p>The ASDx and ASCx pins can be used as a secondary I<sup>2</sup>C interface where an external sensor like a magnetometer can be connected as a peripheral to the device. </p> <p></p> <p>BMI270 Aux I<sup>2</sup>C Pins</p> <p>OSCB and OSDO can act as an auxiliary SPI interface where an external controller can be connected to the device. That can include an external OIS control unit. For more information on implementing the OIS interface, see the Datasheet. </p> <p></p> <p>BMI270 Aux SPI Pins</p>"},{"location":"hardware_overview/#interrupt-pins","title":"Interrupt Pins","text":"<p>Interrupt functionality is available via the INT pins. There are two interrupts available on the 1x1\" board, and 1 interrupt available on the Micro. These pins are configurable to be high or low. </p> <p></p> <p>6DoF BMI270 Interrupt Pins</p> <p></p> <p>Micro 6DoF BMI270 Interrupt Pin</p>"},{"location":"hardware_overview/#jumpers","title":"Jumpers","text":""},{"location":"hardware_overview/#i2c_1","title":"I2C","text":"<p>Like our other Qwiic boards, the Qwiic 6DoF - BMI270 boards come equipped with pull-up resistors on the clock and data pins. If you are daisy-chaining multiple Qwiic devices, you will want to cut this jumper; if multiple sensors are connected to the bus with the pull-up resistors enabled, the parallel equivalent resistance will create too strong of a pull-up for the bus to operate correctly. As a general rule of thumb, disable all but one pair of pull-up resistors if multiple devices are connected to the bus. To disable the pull up resistors, use an X-acto knife to cut the joint between the two jumper pads highlighted below.</p> <p></p> <p>6DoF BMI270 I<sup>2</sup>C Jumper</p> <p></p> <p>Micro 6DoF BMI270 I<sup>2</sup>C Jumper</p>"},{"location":"hardware_overview/#i2c-address","title":"I<sup>2</sup>C Address","text":"<p>The SparkFun 6DoF - BMI270 (Qwiic) boards have a default I<sup>2</sup>C address of 0x68, but by cutting the address jumper on the back of the board, you can select 0x69 (GND) or SPI (fully open). </p> <p>0x68 (default) is actually the GND side, 0x69 is the 3.3V side</p> <p></p> <p>6DoF BMI270 I<sup>2</sup>C Address Jumper</p> <p></p> <p>Micro 6DoF BMI270 I<sup>2</sup>C Address Jumper</p>"},{"location":"hardware_overview/#led","title":"LED","text":"<p>An LED on the front of each board indicates power is being provided to the board. If you don't like LEDs or you are concerned about current draw, cut the jumper highlighted below. </p> <p></p> <p>6DoF BMI270 LED Jumper</p> <p></p> <p>Micro 6DoF BMI270 LED Jumper</p>"},{"location":"hardware_overview/#board-outline","title":"Board Outline","text":"<p>The SparkFun 6DoF - BMI270 (Qwiic) follows the standard 1\" x 1\" convention of most of our Qwiic breakout boards. </p> <p></p> <p>SparkFun 6DoF - BMI270 (Qwiic)</p> <p>The SparkFun 6DoF Micro - BMI270 (Qwiic) measures 0.3\" x 0.75\". </p> <p></p> <p>SparkFun 6DoF Micro - BMI270 (Qwiic)</p>"},{"location":"resources_and_going_further/","title":"Resources","text":"<p>For more information, check out the resources below.</p> <p>SparkFun 6DoF BMI270 1\"x1\" Board: </p> <ul> <li>Schematic (PDF)</li> <li>Eagle Files</li> <li>Board Outline (PNG)</li> <li>GitHub Hardware Repo</li> </ul> <p>SparkFun 6DoF BMI270 Micro Board: </p> <ul> <li>Schematic (PDF)</li> <li>Eagle Files</li> <li>Board Outline (PNG)</li> <li>GitHub Hardware Repo</li> </ul> <p>Or check out other Qwiic Sensor Tutorials:</p> SparkFun Humidity Sensor Breakout - SHTC3 (Qwiic) Hookup Guide              Qwiic Atmospheric Sensor (BME280) Hookup Guide              Qwiic TMP117 High Precision Digital Temperature Sensor Hookup Guide              Qwiic Pressure Sensor (BMP384) Hookup Guide"},{"location":"single_page/","title":"Introduction","text":"<p>The SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) is a Qwiic enabled board based on the ultra-low power BMI270 from Bosch. This chip is a highly integrated, low power IMU designed for wearable, smart clothing and AR/VR applications. Not only does the BMI270 comprise a fast and sensitive accelerometer and gyro pair, but it also contains a number of intelligent, on-chip motion-triggered interrupt features.  </p> <p> Purchase from SparkFun  </p> <p></p> <p>The SparkFun Micro 6DoF IMU Breakout - BMI270 (Qwiic) is the 1x1's mini-me, containing most of it's elder sibling's functionality in a tiny little package. </p> <p> Purchase from SparkFun  </p>"},{"location":"single_page/#required-materials","title":"Required MaterialsSparkFun 6DoF IMU Breakout - BMI270 (Qwiic)SparkFun Micro 6DoF IMU Breakout - BMI270 (Qwiic)Flexible Qwiic Cable - 100mmUSB micro-B Cable - 6 FootSparkFun ESP32 Thing Plus","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary.</p>              SEN-22397                       SEN-22398                       PRT-17259                       CAB-10215                       DEV-15663"},{"location":"single_page/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren\u2019t familiar with the following concepts, we recommend checking out these tutorials before continuing.</p> <ul> <li> <p> I2C </p> </li> <li> <p> Serial Terminal Basics </p> </li> </ul> <p> <p></p> <p>The SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) Sensor takes advantage of the Qwiic connect system. We recommend familiarizing yourself with the Logic Levels and I<sup>2</sup>C tutorials.  Click on the banner above to learn more about Qwiic products.</p> <p> </p>"},{"location":"single_page/#hardware-overview","title":"Hardware Overview","text":""},{"location":"single_page/#accelerometer-bmi270","title":"Accelerometer - BMI270","text":"<p>The ultra-low power BMI270 is an IMU optimized for wearables providing precise acceleration, angular rate measurement and intelligent on-chip motion-triggered interrupt features.</p> <p>The 6-axis sensor combines a 16-bit tri-axial gyroscope and a 16-bit tri-axial accelerometer featuring Bosch\u2019s automotive-proven gyroscope technology. BMI270 includes several functionalities such as an integrated plug-and-play step counter/detector and gesture detection for wrist-worn devices. Moreover, the IMU is suitable for hearables, smart clothes, smart shoes, smart glasses and ankle bands.</p> <p></p> <p>6DoF BMI270 IC</p> <p></p> <p>Micro 6DoF BMI270 IC</p>"},{"location":"single_page/#qwiic-connector","title":"Qwiic Connector","text":"<p>The Qwiic connector(s) on the SparkFun 6DoF - BMI270 (Qwiic) and SparkFun 6DoF Micro - BMI270 (Qwiic) provide power and I<sup>2</sup>C connectivity simultaneously.</p> <p></p> <p>6DoF BMI270 Qwiic Connector</p> <p></p> <p>Micro 6DoF BMI270 Qwiic Connector</p>"},{"location":"single_page/#power","title":"Power","text":"<p>Ideally, power to these boards will be provided by the Qwiic cables. However, should you wish to provide power separately, the 1\" x 1\" board has its pins broken out to PTH and you can wire up power via these. </p> <p>Warning</p> <p><p>Make sure to pay attention to logic levels - supply voltage range should be between 1.71V - 3.6V. </p></p> <p></p> <p>BMI270 Power Pins</p>"},{"location":"single_page/#gpio","title":"GPIO","text":"<p>This is a quick overview of the pin functionality. For more information, refer to the datasheet.</p>"},{"location":"single_page/#i2c","title":"I<sup>2</sup>C","text":"<p>If you do not want to use the Qwiic connectors, I<sup>2</sup>C functionality has been broken out to PTH pins on the 1x1\" board. </p> <p></p> <p>BMI270 I<sup>2</sup>C Pins</p>"},{"location":"single_page/#spi","title":"SPI","text":"<p>Primary SPI functionality has been broken out to the highlighted pins below. </p> <p></p> <p>BMI270 SPI Pins</p> <p>SCL goes to SCK, SDA goes to PICO, ADR goes to POCI, and CS goes to CS</p>"},{"location":"single_page/#auxiliary-interface","title":"Auxiliary Interface","text":"<p>The ASDx and ASCx pins can be used as a secondary I<sup>2</sup>C interface where an external sensor like a magnetometer can be connected as a peripheral to the device. </p> <p></p> <p>BMI270 Aux I<sup>2</sup>C Pins</p> <p>OSCB and OSDO can act as an auxiliary SPI interface where an external controller can be connected to the device. That can include an external OIS control unit. For more information on implementing the OIS interface, see the Datasheet. </p> <p></p> <p>BMI270 Aux SPI Pins</p>"},{"location":"single_page/#interrupt-pins","title":"Interrupt Pins","text":"<p>Interrupt functionality is available via the INT pins. There are two interrupts available on the 1x1\" board, and 1 interrupt available on the Micro. These pins are configurable to be high or low. </p> <p></p> <p>6DoF BMI270 Interrupt Pins</p> <p></p> <p>Micro 6DoF BMI270 Interrupt Pin</p>"},{"location":"single_page/#jumpers","title":"Jumpers","text":""},{"location":"single_page/#i2c_1","title":"I2C","text":"<p>Like our other Qwiic boards, the Qwiic 6DoF - BMI270 boards come equipped with pull-up resistors on the clock and data pins. If you are daisy-chaining multiple Qwiic devices, you will want to cut this jumper; if multiple sensors are connected to the bus with the pull-up resistors enabled, the parallel equivalent resistance will create too strong of a pull-up for the bus to operate correctly. As a general rule of thumb, disable all but one pair of pull-up resistors if multiple devices are connected to the bus. To disable the pull up resistors, use an X-acto knife to cut the joint between the two jumper pads highlighted below.</p> <p></p> <p>6DoF BMI270 I<sup>2</sup>C Jumper</p> <p></p> <p>Micro 6DoF BMI270 I<sup>2</sup>C Jumper</p>"},{"location":"single_page/#i2c-address","title":"I<sup>2</sup>C Address","text":"<p>The SparkFun 6DoF - BMI270 (Qwiic) boards have a default I<sup>2</sup>C address of 0x68, but by cutting the address jumper on the back of the board, you can select 0x69 (GND) or SPI (fully open). </p> <p>0x68 (default) is actually the GND side, 0x69 is the 3.3V side</p> <p></p> <p>6DoF BMI270 I<sup>2</sup>C Address Jumper</p> <p></p> <p>Micro 6DoF BMI270 I<sup>2</sup>C Address Jumper</p>"},{"location":"single_page/#led","title":"LED","text":"<p>An LED on the front of each board indicates power is being provided to the board. If you don't like LEDs or you are concerned about current draw, cut the jumper highlighted below. </p> <p></p> <p>6DoF BMI270 LED Jumper</p> <p></p> <p>Micro 6DoF BMI270 LED Jumper</p>"},{"location":"single_page/#board-outline","title":"Board Outline","text":"<p>The SparkFun 6DoF - BMI270 (Qwiic) follows the standard 1\" x 1\" convention of most of our Qwiic breakout boards. </p> <p></p> <p>SparkFun 6DoF - BMI270 (Qwiic)</p> <p>The SparkFun 6DoF Micro - BMI270 (Qwiic) measures 0.3\" x 0.75\". </p> <p></p> <p>SparkFun 6DoF Micro - BMI270 (Qwiic)</p>"},{"location":"single_page/#hardware-assembly","title":"Hardware Assembly","text":"<p>The delightful thing about our Qwiic boards is that they are quite literally plug and play. </p> <p></p> <p>SparkFun 6DoF IMU Breakout - BMI270 (Qwiic) Plugged into the ESP32 Thing Plus</p> <p></p> <p>SparkFun Micro 6DoF IMU Breakout - BMI270 (Qwiic) Plugged into the ESP32 Thing Plus</p>"},{"location":"single_page/#software-setup-and-programming","title":"Software Setup and Programming","text":"<p>Attention</p> <p>If this is your first time using Arduino, please review our tutorial on installing the Arduino IDE. If you have not previously installed an Arduino library, please check out our installation guide.</p> <p>SparkFun has written a library to work with the SparkFun Qwiic 6DoF BMI270 Boards. You can obtain this library through the Arduino Library Manager by searching for \"BMI270\" and installing the latest version. If you prefer downloading libraries manually, you can grab them from the GitHub Repository.</p> <p> SparkFun Qwiic 6DoF BMI270 Arduino Library GitHub </p> <p>Attention</p> <p>Optical Image Stabilization (OIS) has not been implemented in this library. If you wish to use this functionality, please refer to the datasheet.</p>"},{"location":"single_page/#arduino-examples","title":"Arduino Examples","text":"<p>The Arduino Library for the SparkFun 6DoF BMI270 (Qwiic) comes with a slew of examples to get you going. Here we'll just look at a few. </p> <p>Attention</p> <p><p>The BMI270 chip requires an 8kb file to be flashed to memory on the controller. Make sure that whatever controlling board you use, it has enough space. </p></p>"},{"location":"single_page/#example-1-basic-readings","title":"Example 1: Basic Readings","text":"<p>This first example just does some basic measurements. To find Example 1, go to File &gt; Examples &gt; SparkFun BMI270 Arduino Library &gt; Example01_BasicReadingsI2C:</p> <p></p> <p>Finding Example 1</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 1 Arduino Code <pre><code>#include &lt;Wire.h&gt;\n#include \"SparkFun_BMI270_Arduino_Library.h\"\n\n// Create a new sensor object\nBMI270 imu;\n\n// I2C address selection\nuint8_t i2cAddress = BMI2_I2C_PRIM_ADDR; // 0x68\n//uint8_t i2cAddress = BMI2_I2C_SEC_ADDR; // 0x69\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"BMI270 Example 1 - Basic Readings I2C\");\n\n    // Initialize the I2C library\n    Wire.begin();\n\n    // Check if sensor is connected and initialize\n    // Address is optional (defaults to 0x68)\n    while(imu.beginI2C(i2cAddress) != BMI2_OK)\n    {\n        // Not connected, inform user\n        Serial.println(\"Error: BMI270 not connected, check wiring and I2C address!\");\n\n        // Wait a bit to see if connection is established\n        delay(1000);\n    }\n\n    Serial.println(\"BMI270 connected!\");\n}\n\nvoid loop()\n{\n    // Get measurements from the sensor. This must be called before accessing\n    // the sensor data, otherwise it will never update\n    imu.getSensorData();\n\n    // Print acceleration data\n    Serial.print(\"Acceleration in g's\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(imu.data.accelX, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(imu.data.accelY, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.print(imu.data.accelZ, 3);\n\n    Serial.print(\"\\t\");\n\n    // Print rotation data\n    Serial.print(\"Rotation in deg/sec\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(imu.data.gyroX, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(imu.data.gyroY, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.println(imu.data.gyroZ, 3);\n\n    // Print 50x per second\n    delay(20);\n}\n</code></pre> <p>Make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor. You should see something similar to the following. </p> <p></p> <p>Example 1 Output</p>"},{"location":"single_page/#example-6-calibration-to-nvm","title":"Example 6: Calibration to NVM","text":"<p>This example does some basic calibration of the BMI270 and then allows you to write those calibrations to non volatile memory. To find Example 6, go to File &gt; Examples &gt; SparkFun BMI270 Arduino Library &gt; Example06_CalibrationNVM. </p> <p></p> <p>Finding Example 6</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 6 Arduino Code <pre><code>#include &lt;Wire.h&gt;\n#include \"SparkFun_BMI270_Arduino_Library.h\"\n\n// Create a new sensor object\nBMI270 imu;\n\n// I2C address selection\nuint8_t i2cAddress = BMI2_I2C_PRIM_ADDR; // 0x68\n//uint8_t i2cAddress = BMI2_I2C_SEC_ADDR; // 0x69\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"BMI270 Example 6 - Calibration NVM\");\n\n    // Initialize the I2C library\n    Wire.begin();\n\n    // Check if sensor is connected and initialize\n    // Address is optional (defaults to 0x68)\n    while(imu.beginI2C(i2cAddress) != BMI2_OK)\n    {\n        // Not connected, inform user\n        Serial.println(\"Error: BMI270 not connected, check wiring and I2C address!\");\n\n        // Wait a bit to see if connection is established\n        delay(1000);\n    }\n\n    Serial.println(\"BMI270 connected!\");\n\n    Serial.println(\"Place the sensor on a flat surface and leave it stationary.\");\n    Serial.println(\"Enter any key to begin calibration.\");\n\n    // Throw away any previous inputs\n    while(Serial.available() != 0) {Serial.read();}\n    // Wait for user input\n    while(Serial.available() == 0) {}\n\n    Serial.println();\n    Serial.println(\"Average sensor values before calibration:\");\n    printAverageSensorValues();\n    Serial.println();\n\n    // Perform component retrim for the gyroscope. According to the datasheet,\n    // the gyroscope has a typical error of 2%, but running the CRT can reduce\n    // that error to 0.4%\n    Serial.println(\"Performing component retrimming...\");\n    imu.performComponentRetrim();\n\n    // Perform offset calibration for both the accelerometer and IMU. This will\n    // automatically determine the offset of each axis of each sensor, and\n    // that offset will be subtracted from future measurements. Note that the\n    // offset resolution is limited for each sensor:\n    // \n    // Accelerometer offset resolution: 0.0039 g\n    // Gyroscope offset resolution: 0.061 deg/sec\n    Serial.println(\"Performing acclerometer offset calibration...\");\n    imu.performAccelOffsetCalibration(BMI2_GRAVITY_POS_Z);\n    Serial.println(\"Performing gyroscope offset calibration...\");\n    imu.performGyroOffsetCalibration();\n\n    Serial.println();\n    Serial.println(\"Calibration complete!\");\n    Serial.println();\n    Serial.println(\"Average sensor values after calibration:\");\n    printAverageSensorValues();\n    Serial.println();\n\n    Serial.println(\"These calibration values can be stored in the sensor's non-volatile memory (NVM).\");\n    Serial.println(\"Would you like to save these values to the NVM? If so, enter 'Y'\");\n\n    // Throw away any previous inputs\n    while(Serial.available() != 0) {Serial.read();}\n    // Wait for user input\n    while(Serial.available() == 0) {}\n\n    // Check to see if user wants to save values to NVM\n    if(Serial.read() == 'Y')\n    {\n        Serial.println();\n        Serial.println(\"!!! WARNING !!! WARNING !!! WARNING !!! WARNING !!! WARNING !!!\");\n        Serial.println();\n        Serial.println(\"The BMI270's NVM only supports 14 write cycles TOTAL!\");\n        Serial.println(\"Are you sure you want to save to the NVM? If so, enter 'Y' again\");\n\n        // Throw away any previous inputs\n        while(Serial.available() != 0) {Serial.read();}\n        // Wait for user input\n        while(Serial.available() == 0) {}\n\n        // Check to see if user *really* wants to save values to NVM\n        if(Serial.read() == 'Y')\n        {\n            // Save NVM contents\n            int8_t err = imu.saveNVM();\n\n            // Check to see if the NVM saved successfully\n            if(err == BMI2_OK)\n            {\n                Serial.println();\n                Serial.println(\"Calibration values have been saved to the NVM!\");\n            }\n            else\n            {\n                Serial.print(\"Error saving to NVM, error code: \");\n                Serial.println(err);\n            }\n        }\n    }\n\n    Serial.println();\n    Serial.println(\"Example done!\");\n}\n\n// This helper function samples the sensor several times and prints the average\nvoid printAverageSensorValues()\n{\n    // Variables to store the sum of each sensor axis\n    float accXSum = 0;\n    float accYSum = 0;\n    float accZSum = 0;\n\n    float gyrXSum = 0;\n    float gyrYSum = 0;\n    float gyrZSum = 0;\n\n    // Collect 50 measurements at 50Hz\n    int numSamples = 50;\n    for(int i = 0; i &lt; numSamples; i++)\n    {\n        // Get measurements from the sensor\n        imu.getSensorData();\n\n        // Add this measurement to the running total\n        accXSum += imu.data.accelX;\n        accYSum += imu.data.accelY;\n        accZSum += imu.data.accelZ;\n\n        gyrXSum += imu.data.gyroX;\n        gyrYSum += imu.data.gyroY;\n        gyrZSum += imu.data.gyroZ;\n\n        // Wait for next measurement\n        delay(20);\n    }\n\n    // Print acceleration data\n    Serial.print(\"Acceleration in g's\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(accXSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(accYSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.print(accZSum / numSamples, 3);\n\n    Serial.print(\"\\t\");\n\n    // Print rotation data\n    Serial.print(\"Rotation in deg/sec\");\n    Serial.print(\"\\t\");\n    Serial.print(\"X: \");\n    Serial.print(gyrXSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Y: \");\n    Serial.print(gyrYSum / numSamples, 3);\n    Serial.print(\"\\t\");\n    Serial.print(\"Z: \");\n    Serial.println(gyrZSum / numSamples, 3);\n}\n\nvoid loop()\n{\n    // Nothing to do here\n}\n</code></pre> <p>Again, make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor. You should see something similar to the following.</p> <p></p> <p>Example 6 Output</p> <p>Warning</p> <p>This chip only allows a total of 14 writes. Be mindful of this limit when recalibrating. </p>"},{"location":"single_page/#example-12-step-counter","title":"Example 12: Step Counter","text":"<p>One of the highlights of the BMI270 chip is that it filters out general noise to give you accurate step counts and the like. This example shows the measurements of the BMI270 for walking, running, and when the breakout board is set back down. To find Example 12, go to File &gt; Examples &gt; SparkFun BMI270 Arduino Library &gt; Example12_StepCounter:</p> <p></p> <p>Finding Example 12</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 12 Arduino Code <pre><code>#include &lt;Wire.h&gt;\n#include \"SparkFun_BMI270_Arduino_Library.h\"\n\n// Create a new sensor object\nBMI270 imu;\n\n// I2C address selection\nuint8_t i2cAddress = BMI2_I2C_PRIM_ADDR; // 0x68\n//uint8_t i2cAddress = BMI2_I2C_SEC_ADDR; // 0x69\n\n// Pin used for interrupt detection\nint interruptPin = 5;\n\n// Flag to know when interrupts occur\nvolatile bool interruptOccurred = false;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"BMI270 Example 12 - Step Counter\");\n\n    // Initialize the I2C library\n    Wire.begin();\n\n    // Check if sensor is connected and initialize\n    // Address is optional (defaults to 0x68)\n    while(imu.beginI2C(i2cAddress) != BMI2_OK)\n    {\n        // Not connected, inform user\n        Serial.println(\"Error: BMI270 not connected, check wiring and I2C address!\");\n\n        // Wait a bit to see if connection is established\n        delay(1000);\n    }\n\n    Serial.println(\"BMI270 connected!\");\n\n    // Here we enable the step detector, counter, and activity recognition\n    // features of the BMI270; any combination of these is supported.\n    // \n    // DETECTOR - Triggers an interrupt whenever a step is detected\n    // COUNTER  - Increments a counter whenever a step is detected (detector\n    //            does not need to be enabled). Triggers an interrupt based on\n    //            the step counter watermark (see below)\n    // ACTIVITY - The sensor monitors the motion to determine simple user\n    //            activities, including standing still, walking, and running. An\n    //            interrupt is triggered whenever the activity changes\n    imu.enableFeature(BMI2_STEP_DETECTOR);\n    imu.enableFeature(BMI2_STEP_COUNTER);\n    imu.enableFeature(BMI2_STEP_ACTIVITY);\n\n    // When the step counter feature is enabled, it can trigger an interrupt\n    // every number of steps defined by the watermark. This has a factor of 20x,\n    // so a value of 1 means 20 step intervals. The step counter interrupt is\n    // disabled when the watermark is 0 (default)\n    // \n    // Note - The step counter and detector interrupts share the same bit in the\n    // interrupt status flags registers, so the step detector should be disabled\n    // to actually see the step counter interrupts\n    imu.setStepCountWatermark(1);\n\n    // The BMI270 has 2 interrupt pins. All interrupt conditions can be mapped\n    // to either pin, so we'll just choose the first one for this example\n    // \n    // Note - The step counter and detector interrupts share the same bit in the\n    // interrupt mapping registers, so enabling one enables both\n    imu.mapInterruptToPin(BMI2_STEP_COUNTER_INT, BMI2_INT1);\n    imu.mapInterruptToPin(BMI2_STEP_ACTIVITY_INT, BMI2_INT1);\n\n    // Here we configure the interrupt pins using a bmi2_int_pin_config, which \n    // allows for both pins to be configured simultaneously if needed. Here's a\n    // brief description of each value:\n    // \n    // .pin_type  - Which pin(s) is being configured (INT1, INT2, or BOTH)\n    // .int_latch - Latched or pulsed signal (applies to both pins)\n    // .pin_cfg   - Array of settings for each pin (index 0/1 for INT1/2):\n    //     .lvl       - Active high or low\n    //     .od        - Push/pull or open drain output\n    //     .output_en - Whether to enable outputs from this pin\n    //     .input_en  - Whether to enable inputs to this pin (see datasheet)\n    // \n    // In this case, we set INT1 to pulsed, active high, push/pull\n    bmi2_int_pin_config intPinConfig;\n    intPinConfig.pin_type = BMI2_INT1;\n    intPinConfig.int_latch = BMI2_INT_NON_LATCH;\n    intPinConfig.pin_cfg[0].lvl = BMI2_INT_ACTIVE_HIGH;\n    intPinConfig.pin_cfg[0].od = BMI2_INT_PUSH_PULL;\n    intPinConfig.pin_cfg[0].output_en = BMI2_INT_OUTPUT_ENABLE;\n    intPinConfig.pin_cfg[0].input_en = BMI2_INT_INPUT_DISABLE;\n    imu.setInterruptPinConfig(intPinConfig);\n\n    // Setup interrupt handler\n    attachInterrupt(digitalPinToInterrupt(interruptPin), myInterruptHandler, RISING);\n}\n\nvoid loop()\n{\n    // Wait for interrupt to occur\n    if(interruptOccurred)\n    {\n        // Reset flag for next interrupt\n        interruptOccurred = false;\n\n        Serial.print(\"Interrupt occurred!\");\n        Serial.print(\"\\t\");\n\n        // Get the interrupt status to know which condition triggered\n        uint16_t interruptStatus = 0;\n        imu.getInterruptStatus(&amp;interruptStatus);\n\n        // Check if this is the correct interrupt condition\n        if(interruptStatus &amp; BMI270_STEP_CNT_STATUS_MASK)\n        {\n            Serial.print(\"Step detected! Total step count: \");\n\n            // Get the step count\n            uint32_t count = 0;\n            imu.getStepCount(&amp;count);\n\n            // Print step count\n            Serial.print(count);\n            Serial.print(\"\\t\");\n        }\n        if(interruptStatus &amp; BMI270_STEP_ACT_STATUS_MASK)\n        {\n            Serial.print(\"Step activity changed! New activity: \");\n\n            // Get the step activity\n            uint8_t activity = 0;\n            imu.getStepActivity(&amp;activity);\n\n            // Print step activity\n            switch(activity)\n            {\n                case BMI2_STEP_ACTIVITY_STILL:\n                {\n                    Serial.print(\"Still, resetting step counter\");\n                    imu.resetStepCount();\n                    break;\n                }\n                case BMI2_STEP_ACTIVITY_WALKING:\n                {\n                    Serial.print(\"Walking\");\n                    break;\n                }\n                case BMI2_STEP_ACTIVITY_RUNNING:\n                {\n                    Serial.print(\"Running\");\n                    break;\n                }\n                default:\n                {\n                    Serial.print(\"Unknown!\");\n                    break;\n                }\n            }\n        }\n        if(!(interruptStatus &amp; (BMI270_STEP_CNT_STATUS_MASK | BMI270_STEP_ACT_STATUS_MASK)))\n        {\n            Serial.print(\"Unkown interrupt condition!\");\n        }\n\n        Serial.println();\n    }\n}\n\nvoid myInterruptHandler()\n{\n    interruptOccurred = true;\n}\n</code></pre> <p>The wiring for this example is fairly simple. Use the Qwiic connector as normal, and then you'll need to connect your INT1 pin to pin 5/SCK on the ESP32 Thing Plus. Here's what it looks like:</p> <p></p> <p>Example 12</p> <p>Once you get the correct port and board selected and the code is uploaded, you should see something like the following: </p> <p></p> <p>Example 12 Output</p>"},{"location":"single_page/#troubleshooting","title":"Troubleshooting","text":"<p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p>Create New Forum Account Log Into SparkFun Forums</p>"},{"location":"single_page/#resources","title":"Resources:","text":""},{"location":"software_setup_and_programming/","title":"Software Setup and Programming","text":"<p>Attention</p> <p>If this is your first time using Arduino, please review our tutorial on installing the Arduino IDE. If you have not previously installed an Arduino library, please check out our installation guide.</p> <p>SparkFun has written a library to work with the SparkFun Qwiic 6DoF BMI270 Boards. You can obtain this library through the Arduino Library Manager by searching for \"BMI270\" and installing the latest version. If you prefer downloading libraries manually, you can grab them from the GitHub Repository.</p> <p> SparkFun Qwiic 6DoF BMI270 Arduino Library GitHub </p> <p>Attention</p> <p>Optical Image Stabilization (OIS) has not been implemented in this library. If you wish to use this functionality, please refer to the datasheet.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p>Create New Forum Account Log Into SparkFun Forums</p>"}]}